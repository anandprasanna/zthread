#!/usr/bin/env python3
# Delaunay Tessellator
# Written by Arjun Srinivasan

from numpy import array,sum as arrsum,zeros
from scipy.spatial import Delaunay
from pdb_parser import parse_pdb_file, download_pdb_file, open_pdb_file

POTENTIAL_DICT_FILE = "potential_1417.out"
TO_ONE_LETTER_CODE={'ALA':'A', 'VAL':'V', 'PHE':'F', 'PRO':'P', 'MET':'M','ILE':'I', 'LEU':'L', 'ASP':'D', 'GLU':'E', 'LYS':'K','ARG':'R', 'SER':'S', 'THR':'T', 'TYR':'Y', 'HIS':'H','CYS':'C', 'ASN':'N', 'GLN':'Q', 'TRP':'W', 'GLY':'G'}
TOLC = TO_ONE_LETTER_CODE
T3LC = {y:x for x,y in TOLC.items()}

def generate_potential_dictionary():
	""" Generate the potential dictionary for four-body potentials based on previous data. """
	with open(POTENTIAL_DICT_FILE, 'r') as f:
		return {x.split()[0] : float(x.split()[1]) for x in f}

POTENTIAL_DICT = generate_potential_dictionary()

def filter_target(pdbstruct, name='all', span='all', chain='all'):
	""" Filters a protein structure based on given information.
	
	Arguments:
	pdbstruct -- A dictionary pdb structure as created by the parser.
	name -- A list of atom types to handle. For example, CA.
	span -- Resseq values that are accepted. Values are entered as arguments to range.
	chain -- Chains to parse.
	"""
	# Warnings for missing residues:
	if 'REMARK' in pdbstruct and 465 in pdbstruct['REMARK']:
		print("The following residues are missing (residue, chain, resseq, icode): "+str(pdbstruct['REMARK'][465]))

	return [x for x in pdbstruct['ATOM'] if (span == 'all' or x['resseq'] in span) and (name == 'all' or x['name'] in name) and (chain == 'all' or x['chain'] in chain)]


def tessellate(atoms):
	""" Performs a Delaunay tessellation on a given list of atoms.
	
	Arguments:
	atoms -- List of atoms to triangulate.

	Returns:
	A SciPy Delaunay object (contains info about vertices and neighbors)
	"""
	return Delaunay(array([x['coord'] for x in atoms]))


def simplex_potential(atomlist):
	""" Calculates the potential of each simplex.

	Arguments:
	atomlist -- List of Delaunay triangulation vertices containing residues.
	"""
	res_strings = [''.join([TOLC[y] for y in x]) for x in atomlist]
	return [(x, POTENTIAL_DICT[''.join(sorted(x))]) for x in res_strings]

def residue_potential(num_atoms, vertices, simplexlist):
	""" Calculates the potential of each residue (based on surrounding simplices)

	Arguments:
	num_atoms -- Number of atom objects.
	vertices -- Numbered Delaunay triangulation vertices.
	simplexlist -- List generated by simplex_potential.
	"""
	res_pots = zeros(num_atoms)
	for x,y in zip(vertices, simplexlist):
		for e in x:
			res_pots[e] += y[1]
	return res_pots

# test code below here
#a = filter_target(parse_pdb_file(open_pdb_file('/home/asriniva/Downloads/3KXU.pdb'), ['ATOM', 'REMARK'], [465]), chain=['A'], name=['CA'])
#b = tessellate(a).vertices
#c = [[a[x]['res'] for x in y] for y in b]
#d = simplex_potential(c)
#[print(x['resseq'],x['res'],y) for x,y in zip(a,residue_potential(a, b, d))]
